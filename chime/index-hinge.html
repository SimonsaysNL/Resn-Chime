<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - glTF loader</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>
        
<!--        <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.5.1/gsap.min.js"></script>-->
        
        
        <div id="info">
            <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - Resn chime<br />
            Hit bar with sphere
        </div>

        <script type="module">

            import * as THREE from '../build/three.module.js';
            import { GLTFLoader } from './jsm/loaders/GLTFLoader.js';
            import { GUI } from './jsm/libs/dat.gui.module.js';
            import Stats from './jsm/libs/stats.module.js';
            import { BufferGeometryUtils } from './jsm/utils/BufferGeometryUtils.js';
            //import '../build/cannon.js';
            import { OrbitControls } from './jsm/controls/OrbitControls.js';
            import '../build/bllem-cannon.js';

            let camera, scene, renderer, world, mass, body, shape, geometry, material, mesh, flipperleft, flipperright, field, bumperleft, bumperright, object, c, c2, c3, c4, c5, h;
            
            const timeStep = 1/60;
            
            const clock = new THREE.Clock();

            const manager = new THREE.LoadingManager();
            
            let loadingDone = false;
            
            let loaded = {};
            
            let balls = {};
            let ballscount = 0;
            let balllaunched = false;
            
            let barbody, barbody2, barbody3, barbody4, barbody5;
            let barshape;
            let bar, bar2, bar3, bar4, bar5, bar6;
            let group;
            
            const barheight = 10;
            const barsize = 4;
            
            let sphereHinge;
            let hingebody;
            
            let mouse = {x: 0, y: 0};
            
            let bodies = {}
            
            const cannonMaterials = {};
            
            cannonMaterials["mat"] = new CANNON.Material();
            cannonMaterials["groundMaterial"] = new CANNON.Material();
            cannonMaterials["bumperMaterial"] = new CANNON.Material();
            cannonMaterials["slingshotMaterial"] = new CANNON.Material();
            
            const mat_ground = new CANNON.ContactMaterial(cannonMaterials["groundMaterial"], cannonMaterials["mat"], { friction: 0.0, restitution: 0.2 });
            const mat_bumper = new CANNON.ContactMaterial(cannonMaterials["bumperMaterial"], cannonMaterials["mat"], { friction: 0.0, restitution: 1.5 });
            const mat_slingshot = new CANNON.ContactMaterial(cannonMaterials["slingshotMaterial"], cannonMaterials["mat"], { friction: 0.4, restitution: 1.5 });
            const mat_flipper = new CANNON.ContactMaterial(cannonMaterials["flipperMaterial"], cannonMaterials["mat"], { friction: 0.0, restitution: 1.5 });
            
            const matStdObjects = new THREE.MeshLambertMaterial({color: 0xffffff});
            //const matStdObjects = new THREE.MeshLambertMaterial({color: 0xffffff});
            
            let models = {};
            
            const stats = new Stats();
            document.body.appendChild( stats.dom );
            
            init();
            initCannon();
            createBall();
            createBar();
            
            function initCannon() {
                
                const radius = 2; // m
                const damping = 0.01;

                world = new CANNON.World();
                world.gravity.set(0, 0, 0); // m/sÂ²
                world.broadphase = new CANNON.NaiveBroadphase();
                //world.solver.iterations = 10;

                shape = new CANNON.Sphere(radius);
                mass = 1;
                body = new CANNON.Body({
                    mass: 0,
                    material: cannonMaterials["mat"],
                    ccdSpeedThreshold: 0,
                    position: new CANNON.Vec3(-10, 0, 0) // m
                });
                
                barshape = new CANNON.Cylinder(3, 3, barheight, 32);
                barbody = new CANNON.Body({
                    mass: mass,
                    material: cannonMaterials["mat"],
                    ccdSpeedThreshold: 0,
                    position: new CANNON.Vec3(0, 0, 0) // m
                });
                
                barbody2 = new CANNON.Body({
                    mass: mass,
                    material: cannonMaterials["mat"],
                    ccdSpeedThreshold: 0,
                    position: new CANNON.Vec3(0, 0, 0) // m
                });
                
                barbody3 = new CANNON.Body({
                    mass: mass,
                    material: cannonMaterials["mat"],
                    ccdSpeedThreshold: 0,
                    position: new CANNON.Vec3(0, 0, 0) // m
                });
                
                barbody4 = new CANNON.Body({
                    mass: mass,
                    material: cannonMaterials["mat"],
                    ccdSpeedThreshold: 0,
                    position: new CANNON.Vec3(0, 0, 0) // m
                });
                
                barbody5 = new CANNON.Body({
                    mass: mass,
                    material: cannonMaterials["mat"],
                    ccdSpeedThreshold: 0,
                    position: new CANNON.Vec3(0, 0, 0) // m
                });
                
                hingebody = new CANNON.Body({
                    mass: 0,
                    material: cannonMaterials["mat"],
                    ccdSpeedThreshold: 0,
                    position: new CANNON.Vec3(0, 0, 0) // m
                });
                
                body.addShape(shape);
                body.linearDamping = damping;
                body.velocity.set(0,0,0);
                
                barbody.addShape(barshape, new CANNON.Vec3( 0, 0, 0));
                barbody2.addShape(barshape, new CANNON.Vec3( 0, 0, barheight));
                barbody3.addShape(barshape, new CANNON.Vec3( 0, 0, -barheight));
                barbody4.addShape(barshape, new CANNON.Vec3( 0, 0, barheight*2));
                barbody5.addShape(barshape, new CANNON.Vec3( 0, 0, -barheight*2));
                barbody.linearDamping = damping;
                barbody2.linearDamping = damping;
                barbody3.linearDamping = damping;
                barbody4.linearDamping = damping;
                barbody5.linearDamping = damping;
                barbody.velocity.set(0,0,0);
                barbody2.velocity.set(0,0,0);
                barbody3.velocity.set(0,0,0);
                barbody4.velocity.set(0,0,0);
                barbody5.velocity.set(0,0,0);

                hingebody.addShape(shape);
                hingebody.linearDamping = damping;
                hingebody.velocity.set(0,0,0);
                
                world.addBody(body);
                world.addBody(barbody);
                world.addBody(barbody2);
                world.addBody(barbody3);
                world.addBody(barbody4);
                world.addBody(barbody5);
                world.addBody(hingebody);
                
                // Create a plane
                const groundBody = new CANNON.Body({
                    mass: 0,
                    material: cannonMaterials["groundMaterial"]
                });
                const groundShape = new CANNON.Plane();
                groundBody.addShape(groundShape);
                //world.addBody(groundBody);
                
                world.addContactMaterial(mat_ground);
                world.addContactMaterial(mat_bumper);
                world.addContactMaterial(mat_slingshot);
                
                animate();

            }

            function init() {

                const container = document.createElement( 'div' );
                document.body.appendChild( container );

                camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
                camera.position.set( 0, 0, 50 );

                scene = new THREE.Scene();
                scene.background = new THREE.Color( 0x000000 );
                
                const light = new THREE.AmbientLight( 0x404040 ); // soft white light
                scene.add( light );
                
                const spotLight = new THREE.SpotLight( 0xffffff,1 );
                spotLight.position.set( 0, 20, -50 );
                scene.add( spotLight );
                
                const geometry = new THREE.SphereGeometry();
                const material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );
                sphereHinge = new THREE.Mesh( geometry, material );
                scene.add( sphereHinge );
                
//                checkLoaded();
                
//                Object.keys(gltflist).forEach(key => {                   
//                    loaded[key] = new loadmodel(gltflist[key].modelpath, gltflist[key].modelfile, gltflist[key].size, gltflist[key].smooth, key, gltflist[key].posx, gltflist[key].posy, gltflist[key].posz, gltflist[key].rotation, gltflist[key].meshmat, gltflist[key].mass);
//                });

                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1;
                renderer.outputEncoding = THREE.sRGBEncoding;
                container.appendChild( renderer.domElement );
                
//                const controls = new OrbitControls( camera, renderer.domElement );
//                controls.addEventListener( 'change', render ); // use if there is no animation loop
//                controls.minDistance = 2;
//                controls.maxDistance = 40;
//                controls.target.set( 0, 0, 0 );
//                controls.update();

				window.addEventListener( 'resize', onWindowResize );
                
                document.addEventListener('mousemove', onMouseMove, false);
                
                //console.log(loaded);

			}
            
            // Follows the mouse event
            function onMouseMove(event) {

                // Update the mouse variable
                event.preventDefault();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

             // Make the sphere follow the mouse
                var vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
                vector.unproject( camera );
                var dir = vector.sub( camera.position ).normalize();
                var distance = - camera.position.z / dir.z;
                var pos = camera.position.clone().add( dir.multiplyScalar( distance ) );
                body.position.copy(pos);

                // Make the sphere follow the mouse
                //	mouseMesh.position.set(event.clientX, event.clientY, 0);
            };
            
            function loadmodel(modelpath, modelfile, meshsize, smooth, scenekey, posx, posy, posz, rotation, meshmat, modelmass) {
                
                this.smooth = smooth;
                
                this.loader = new GLTFLoader(manager).setPath(modelpath);
                this.loader.load( modelfile, function ( gltf ) {
                    
                    this.gltf = gltf;
                    
                    //For wireframe look
//                     this.gltf.scene.traverse((node) => {
//                        if (!node.isMesh) return;
//                        node.material.wireframe = true;
//                    });

                    this.gltf.scene.traverse( function ( child ) {
                        if ( child.isMesh ) {
                            child.material = matStdObjects;
                            child.castShadow = true;
				            child.receiveShadow = true;
                            child.doubleSided = false;
                        }
                    });

                    this.gltf.scene

//                    if(this.smooth == 1) {
//                        setSmoothGeometry(this.gltf.scene);
//                    }
//
//                    function setSmoothGeometry(obj) {
//                        obj.traverse(node => {
//                            if ('geometry' in node) {
//                                const tempGeometry = new THREE.Geometry().fromBufferGeometry( node.geometry );
//                                tempGeometry.mergeVertices();
//                                tempGeometry.computeVertexNormals();
//                                node.geometry = new THREE.BufferGeometry().fromGeometry( tempGeometry );
//                            }
//                        })
//                    }
                    
                   
                    let glTFGeometry;
                    
                    let scale;
                    
                    // Might be used someday, have to look into bufferGeometry
                    //let glTFGeometry = new THREE.BufferGeometry();
                    
                    this.gltf.scene.traverse( function ( child ) {

                        if ( child.isMesh ) {
                            //child.material.envMap = envMap;
                            //Setting the buffer geometry
                            //glTFGeometry = child.geometry;
                            glTFGeometry = new THREE.Geometry().fromBufferGeometry(child.geometry);
                            //console.log(glTFGeometry);
                            scale = child.scale;
                        }

                    } );
                    
                    

                    let vertices = [], faces = [];

                    // Add vertices
                    for (let i = 0; i < glTFGeometry.vertices.length; i++) {

                        let x = scale.x * glTFGeometry.vertices[i].x;
                        let y = scale.y * glTFGeometry.vertices[i].y;
                        let z = scale.z * glTFGeometry.vertices[i].z;

                        vertices.push(new CANNON.Vec3(x, y, z));
                    }

                    for (let i = 0; i < glTFGeometry.faces.length; i++) {

                        let a = glTFGeometry.faces[i].a;
                        let b = glTFGeometry.faces[i].b;
                        let c = glTFGeometry.faces[i].c;

                        faces.push([a, b, c]);
                    }
                    
                    shape = new CANNON.ConvexPolyhedron(vertices, faces);
                    
                    let gltfBody = new CANNON.Body({
                        
                        mass: modelmass,
                        material: cannonMaterials[meshmat],
                        position: new CANNON.Vec3(posx, posy, posz) // m
                    });
//                    const groundShape = new CANNON.Plane();
//                    console.log(glTFGeometry);
//                    console.log(groundShape);
                    const gltfShape = glTFGeometry;
                    gltfBody.addShape(shape);
                    
                    bodies[scenekey] = gltfBody;
                    
                    
                    this.gltf.scene.castShadow = true;
				    this.gltf.scene.receiveShadow = true;

//                  this.gltf.scene.scale.set( meshsize, meshsize, meshsize )
//                  positionObject(this.gltf.scene, gltflist[scenekey].posx, gltflist[scenekey].posy, gltflist[scenekey].posz);
                    scene.add( this.gltf.scene );
                    
                    const radians = THREE.Math.degToRad( rotation );
                    const quaternion = new THREE.Quaternion();
                    gltfBody.quaternion.setFromAxisAngle( new THREE.Vector3(0,1,0), radians );
                
                    this.gltf.scene.position.copy(gltfBody.position);
                    this.gltf.scene.quaternion.copy(gltfBody.quaternion);
                    world.addBody(bodies[scenekey]);
                    
                }.bind(this));
            }
            
            //Check if assets loaded
            function checkLoaded() {
                manager.onStart = function ( url, itemsLoaded, itemsTotal ) {
                    //console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
                };

                manager.onLoad = function ( ) {
                    console.log( 'Loading complete!');
                    loadingDone = true;
                    initMachine();
                };

                manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
                    //console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
                };

                manager.onError = function ( url ) {
                    console.log( 'There was an error loading ' + url );
                };
            }
            
            //Set position object
            function positionObject(object, posX=0, posY=0, posZ=0) {
                object.translateX(posX);
                object.translateY(posY);
                object.translateZ(posZ);
            }
            
            //Create ball
            function createBall() {
                const geometry = new THREE.SphereGeometry( 2, 32, 32 );
                const material = new THREE.MeshNormalMaterial();
                const sphere = new THREE.Mesh( geometry, material );
//                sphere.translateX(posX);
//                sphere.translateY(posY);
//                sphere.translateZ(-13);
                scene.add( sphere );
                balls[ballscount] = sphere; 
                ballscount++;
                console.log(balls);
            }
            
            //Create bar
            function createBar() {
                const geometry = new THREE.CylinderGeometry( 3.1, 3.1, barheight+0.1, 32 );
                const fullgeometry = new THREE.CylinderGeometry( 3, 3, barheight*5, 32 );
                geometry.rotateX(Math.PI/2);
                fullgeometry.rotateX(Math.PI/2);
                const material = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    opacity: 0,
                    transparent: true
                });
                const material2 = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    opacity: 1,
                    transparent: true
                });
                const material3 = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    opacity: 1,
                    transparent: true
                });
                const material4 = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    opacity: 1,
                    transparent: true
                });
                const material5 = new THREE.MeshStandardMaterial({
                    color: 0xffffff,
                    opacity: 1,
                    transparent: true
                });
                const normalmaterial = new THREE.MeshNormalMaterial();
                bar = new THREE.Mesh( geometry, material );
                bar2 = new THREE.Mesh( geometry, material5 );
                bar3 = new THREE.Mesh( geometry, material4 );
                bar4 = new THREE.Mesh( geometry, material3 );
                bar5 = new THREE.Mesh( geometry, material2 );
                bar6 = new THREE.Mesh( fullgeometry, normalmaterial );
                bar.position.set(0,0,0);
                scene.add( bar );
                bar2.position.set(0,0,barheight);
                scene.add( bar2 );
                bar3.position.set(0,0,-barheight);
                scene.add( bar3 );
                bar4.position.set(0,0,barheight*2);
                scene.add( bar4 );
                bar5.position.set(0,0,-barheight*2);
                scene.add( bar5 );
                bar6.position.set(0,0,0);
                //scene.add( bar6 );
//                group = new THREE.Group();
//                group.add( bar );

                body.addEventListener("collide",function(e){
//                  console.log("Collided with body:",e.body);
//                  console.log("Contact between bodies:",e.contact);
                    console.log("Collided with body:",e.body.id);
                    
                    if (e.body.id == "3") {
                        bar5.material.color.set( Math.random() * 0xffffff );
                        bar5.material.opacity = 0.5;
                    }
                    
                    if (e.body.id == "2") {
                        bar4.material.color.set( Math.random() * 0xffffff );
                        bar4.material.opacity = 0.5;
                    }
                    
                    if (e.body.id == "1") {
                        bar.material.color.set( Math.random() * 0xffffff );
                        bar.material.opacity = 0.5;
                    }
                    
                });
                
                c = new CANNON.HingeConstraint(hingebody, barbody, {
                    pivotA: new CANNON.Vec3(0,0,0),
                    axisA: new CANNON.Vec3(1,1,1),
                    pivotB: new CANNON.Vec3(0,0,0),
                    axisB: new CANNON.Vec3(1,1,1),
                    //maxForce:0
                });
                c2 = new CANNON.HingeConstraint(barbody, barbody2, {
                    pivotA: new CANNON.Vec3(0,0,barheight),
                    axisA: new CANNON.Vec3(0,0,1),
                    pivotB: new CANNON.Vec3(0,0,0),
                    axisB: new CANNON.Vec3(0,0,1),
                });
                c3 = new CANNON.HingeConstraint(barbody, barbody3, {
                    pivotA: new CANNON.Vec3(0,0,-barheight),
                    axisA: new CANNON.Vec3(0,0,1),
                    pivotB: new CANNON.Vec3(0,0,0),
                    axisB: new CANNON.Vec3(0,0,1),
                });
                c4 = new CANNON.HingeConstraint(barbody2, barbody4, {
                    pivotA: new CANNON.Vec3(0,0,barheight*2),
                    axisA: new CANNON.Vec3(0,0,1),
                    pivotB: new CANNON.Vec3(0,0,0),
                    axisB: new CANNON.Vec3(0,0,1),
                });
                c5 = new CANNON.HingeConstraint(barbody3, barbody5, {
                    pivotA: new CANNON.Vec3(0,0,-barheight*2),
                    axisA: new CANNON.Vec3(0,0,1),
                    pivotB: new CANNON.Vec3(0,0,0),
                    axisB: new CANNON.Vec3(0,0,1),
                });
                world.addConstraint(c);
                world.addConstraint(c2);
                world.addConstraint(c3);
                world.addConstraint(c4);
                world.addConstraint(c5);
            }
            
            
            function radians_to_degrees(radians)
            {
              const pi = Math.PI;
              return radians * (180/pi);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
                render();
            }
            

            function updatePhysics() {

                // Step the physics world
                world.step(timeStep);
//                if(balls[0]) console.log(balls[0].position);
//                console.log(body);
//                console.log(bar);

//                if(loadingDone) {
                if(balls[0]) {
//                    // Copy coordinates from Cannon.js to Three.js
                    balls[0].position.copy(body.position);
                    balls[0].quaternion.copy(body.quaternion);
                    bar.position.copy(barbody.position);
                    bar.quaternion.copy(barbody.quaternion);
                    bar2.position.copy(barbody2.position);
                    bar2.quaternion.copy(barbody2.quaternion);
                    bar3.position.copy(barbody3.position);
                    bar3.quaternion.copy(barbody3.quaternion);
                    bar4.position.copy(barbody4.position);
                    bar4.quaternion.copy(barbody4.quaternion);
                    bar5.position.copy(barbody5.position);
                    bar5.quaternion.copy(barbody5.quaternion);
                    bar6.position.copy(barbody.position);
                    bar6.quaternion.copy(barbody.quaternion);
                    sphereHinge.position.copy(hingebody.position);
                    sphereHinge.quaternion.copy(hingebody.quaternion);
//                    loaded.c.gltf.scene.position.copy(bodies.c.position);
//                    loaded.c.gltf.scene.quaternion.copy(bodies.c.quaternion);
//                    loaded.h.gltf.scene.position.copy(bodies.h.position);
//                    loaded.h.gltf.scene.quaternion.copy(bodies.h.quaternion);
                }

            }
            
            function animate() {
                //console.log("animate")
                requestAnimationFrame( animate );
                updatePhysics(); //moved to gameloop
                render();
                stats.update();
            }

			function render() {
				renderer.render( scene, camera );
			}

		</script>

	</body>
</html>